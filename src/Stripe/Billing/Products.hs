module Stripe.Billing.Products where

import Stripe.Core
import Stripe.Utils

data PackageDimensions = PackageDimensions
  { packageDimensionsHeight :: Double
  , packageDimensionsLength :: Double
  , packageDimensionsWeight :: Double
  , packageDimensionsWidth :: Double
  } deriving (Show, Eq, Generic, Typeable)

instance FromJSON PackageDimensions where
  parseJSON = parseObject "PackageDimensions" $ do
    PackageDimensions
      <$> req "height"
      <*> req "length"
      <*> req "weight"
      <*> req "width"

data ProductType
  = Good
  | Service
  deriving (Show, Eq, Generic, Typeable)

instance FromJSON ProductType where
  parseJSON = withText "ProductType" $ \t -> case t of
    "good" -> pure Good
    "service" -> pure Service
    _ -> fail ("Invalid ProductType: " ++ show t)

data Product = Product
  { productId :: Id Product
  , productActive :: Bool
  , productAttributes :: [Text]
  , productCaption :: Maybe Text
  , productCreated :: Timestamp
  , productDeactivateOn :: [Id Application]
  , productDescription :: Maybe Text
  , productImages :: [Text]
  , productLiveMode :: Bool
  , productMetadata :: Metadata
  , productName :: Text
  , productPackageDimensions :: Maybe PackageDimensions
  , productShippable :: Maybe Bool
  , productStatementDescriptor :: Maybe Text
  , productType_ :: ProductType
  , productUnitLabel :: Maybe Text
  , productUpdated :: Maybe Timestamp
  , productUrl :: Maybe Text
  } deriving (Show, Eq, Generic, Typeable)

instance FromJSON Product where
  parseJSON = parseObject "Product" $ do
    assertObject "product"
    Product
      <$> req "id"
      <*> req "active"
      <*> req "attributes"
      <*> opt "caption"
      <*> req "created"
      <*> lst "deactivate_on"
      <*> req "description"
      <*> req "images"
      <*> req "livemode"
      <*> req "metadata"
      <*> req "name"
      <*> opt "package_dimensions"
      <*> opt "shippable"
      <*> opt "statement_descriptor"
      <*> req "type"
      <*> opt "unit_label"
      <*> opt "updated"
      <*> opt "url"

createProduct :: (MonadStripe m, StripeResult Product product) => NewProduct -> m product
createProduct = stripePost (Proxy @Product) "products"

-- TODO this takes a number of different things for service vs good products, need to consolidate the two.

data NewProduct = NewProduct
  { newProductId :: Maybe (Id Product) -- ^ An identifier will be randomly generated by Stripe. You can optionally override this ID, but the ID must be unique across all products in your Stripe account. Applicable to both service and good types.
  , newProductName :: Text -- ^ The product’s name, meant to be displayable to the customer. Applicable to both service and good types.
  , newProductType :: ProductType -- ^ The type of the product. The product is either of type service, which is eligible for use with Subscriptions and Plans or good, which is eligible for use with Orders and SKUs.
  , newProductActive :: Maybe Bool -- ^ Whether the product is currently available for purchase. Defaults to true.
  , newProductAttributes :: [Text] -- ^ A list of up to 5 alphanumeric attributes. Applicable to both service and good types.
  , newProductCaption :: Maybe Text -- ^ A short one-line description of the product, meant to be displayable to the customer. May only be set if type=good
  -- TODO , newProductDeactivateOn
  -- , newProduct
  , newProductMetadata :: Metadata
  , newProductStatementDescriptor :: Maybe Text -- ^ An arbitrary string to be displayed on your customer’s credit card statement. This may be up to 22 characters. The statement description may not include <>”’ characters, and will appear on your customer’s statement in capital letters. Non-ASCII characters are automatically stripped. While most banks display this information consistently, some may display it incorrectly or not at all. It must contain at least one letter. May only be set if type=service.
  , newProductUnitLabel :: Maybe Text -- ^ A label that represents units of this product, such as seat(s), in Stripe and on customers’ receipts and invoices. Only available on products of type=service.
  }

instance ToHttpApiData ProductType where
  toQueryParam Good = "good"
  toQueryParam Service = "service"

instance ToForm NewProduct where
  toForm NewProduct{..} = mconcat
    [ optParam "id" newProductId
    , reqParam "name" newProductName
    , reqParam "type" newProductType
    , optParam "active" newProductActive
    , arrayParams "attributes" newProductAttributes
    , hashParams "metadata" newProductMetadata
    , optParam "statement_descriptor" newProductStatementDescriptor
    , optParam "unit_label" newProductUnitLabel
    ]


retrieveProduct :: (MonadStripe m, StripeResult Product product) => Id Product -> m product
retrieveProduct (Id productId) = stripeGet (Proxy @Product) ("products/" <> encodeUtf8 productId) []

-- updateProduct
data UpdateProduct

data ListAllProductsQuery = ListAllProductsQuery
  { listAllProductsQueryActive :: Maybe Bool
  -- TODO , listAllProductsQueryCreated
  , listAllProductsQueryIds :: Maybe [Id Product]
  , listAllProductsQueryShippable :: Maybe Bool
  , listAllProductsQueryType_ :: Maybe ProductType
  , listAllProductsQueryUrl :: Maybe Text
  }

instance ToForm ListAllProductsQuery where
  toForm ListAllProductsQuery{..} = mconcat
    [ optParam "active" listAllProductsQueryActive
    -- , optParam "ids" listAllProductsQueryIds
    , optParam "shippable" listAllProductsQueryShippable
    , optParam "type" listAllProductsQueryType_
    , optParam "url" listAllProductsQueryUrl
    ]

instance BaseQuery ListAllProductsQuery where
  baseQuery = ListAllProductsQuery Nothing Nothing Nothing Nothing Nothing

listAllProducts ::
     (MonadStripe m, StripeResult (List Product) productList)
  => ListAllProductsQuery
  -> Pagination Product
  -> m productList
listAllProducts pq = stripeGet (Proxy @(List Product)) "products" . joinParams pq . paginationParams

-- deleteProduct
data DeleteProduct
